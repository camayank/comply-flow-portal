Brilliant. Here’s a practical, Replit-ready upgrade pack that will delight both customers (clarity + zero chasing) and employees (structured, fast workflows) — while keeping your Admin totally no-code.

I’m giving you:

1. A zero-dependency Admin UI (single HTML) to manage Services Catalog, Workflow JSON, Doc Types, Due Date Master, and Entity–Service binding


2. A lightweight Ops Board to change statuses quickly (so event-driven messages go out)


3. The API glue you’ll add to your existing Replit server (CORS + static + a few endpoints)



Copy–paste and you’re live.


---

1) Server updates (index.js)

Add CORS, static hosting for the UI, and wire the new routes.

// index.js (add these near the top)
import express from 'express';
import dotenv from 'dotenv';
dotenv.config();

import cors from 'cors';                   // NEW
const app = express();
app.use(cors());                           // NEW – allow your admin UI to call APIs
app.use(express.json());
app.use(express.static('public'));         // NEW – serve admin & ops pages

// ... existing imports stay ...
import adminRoutes from './routes/admin.js';
import serviceOrders from './routes/serviceOrders.js';
import documents from './routes/documents.js';

app.use('/admin', adminRoutes);
app.use('/service-orders', serviceOrders);
app.use('/documents', documents);

// Health
app.get('/', (_, res) => res.send('DigiComply OK'));

Install CORS:

npm i cors


---

2) Extra API glue

2.1 List service orders for Ops (extend routes/serviceOrders.js)

// routes/serviceOrders.js
import express from 'express';
import db from '../db.js';
import { emitEvent } from '../eventBus.js';

const router = express.Router();

// LIST all (basic filters)
router.get('/', (req, res) => {
  const { status, service_type } = req.query;
  let sql = `select s.*, e.name as entity_name from service_orders s 
             join entities e on e.id=s.entity_id where 1=1`;
  const params = [];
  if (status) { sql += ` and s.status = ?`; params.push(status); }
  if (service_type) { sql += ` and s.service_type = ?`; params.push(service_type); }
  sql += ` order by s.due_date asc, s.updated_at desc`;

  const rows = db.prepare(sql).all(...params);
  res.json(rows);
});

// GET one
router.get('/:id', (req, res) => {
  const row = db.prepare(`select s.*, e.name as entity_name from service_orders s 
                          join entities e on e.id=s.entity_id where s.id=?`).get(req.params.id);
  if (!row) return res.status(404).json({ error:'Not found' });
  res.json(row);
});

// UPDATE status (already added earlier – keep as is)
router.patch('/:id/status', (req, res) => {
  const id = Number(req.params.id);
  const { from, to, ackNo, pendingItem } = req.body || {};
  const so = db.prepare(`select * from service_orders where id = ?`).get(id);
  if (!so) return res.status(404).json({ error: 'Not found' });

  db.prepare(`update service_orders set status = ?, updated_at = datetime('now') where id = ?`).run(to, id);
  emitEvent('service.status_changed', {
    service_order_id: id, from, to, ackNo, pendingItem,
    serviceName: so.service_type, periodLabel: so.period_label
  });
  res.json({ ok: true });
});

export default router;


---

3) Public UI (no build tools, just HTML+JS)

Create a public/ folder with two pages:

public/
├─ admin.html
└─ ops.html


---

3.1 Admin UI (public/admin.html)

Manage Services Catalog

Manage Doc Types for a service

Manage Workflow Template JSON (version + publish)

Manage Due Date Master rules

Bind Services → Entities

Run a quick preview to ensure rules are being applied


<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DigiComply Admin (No-Code)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    h2 { margin-top: 32px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin:12px 0; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; }
    input, select, textarea, button { padding:8px 10px; border-radius:8px; border:1px solid #e5e7eb; font-size:14px; }
    button { background:#111827; color:#fff; border:none; cursor:pointer; }
    label { font-size:12px; color:#374151; }
    textarea { width:100%; min-height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .muted { color:#6b7280; font-size:12px; }
    table { border-collapse: collapse; width:100%; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; font-size:14px; }
    .pill { padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:12px; }
    .ok { color:#059669; }
    .err { color:#b91c1c; }
    .grid { display:grid; gap:16px; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
  </style>
</head>
<body>
  <h1>DigiComply Admin (No-Code)</h1>
  <p class="muted">Create default services, attach document types, publish workflow JSON, and define Due Date Master rules. Bind services to clients and let the system spawn periods + reminders.</p>

  <!-- SERVICES CATALOG -->
  <h2>1) Services Catalog</h2>
  <div class="card">
    <div class="row">
      <div><label>Service Key<br/><input id="svc_key" placeholder="gst_returns"/></label></div>
      <div><label>Name<br/><input id="svc_name" placeholder="GST Returns Filing"/></label></div>
      <div><label>Periodicity<br/>
        <select id="svc_periodicity">
          <option>ONE_TIME</option><option>MONTHLY</option><option>QUARTERLY</option><option>ANNUAL</option>
        </select></label>
      </div>
      <div><label>Description<br/><input id="svc_desc" placeholder="Periodic GST return filings"/></label></div>
      <button onclick="addService()">Add Service</button>
      <button onclick="loadServices()">Refresh</button>
    </div>
    <div id="svc_list" style="margin-top:12px;"></div>
  </div>

  <!-- DOC TYPES -->
  <h2>2) Service Doc Types</h2>
  <div class="card">
    <div class="row">
      <div><label>Service Key<br/><input id="doc_service_key" placeholder="gst_returns"/></label></div>
      <div><label>Doc Type<br/><input id="doc_doctype" placeholder="sales_register_csv"/></label></div>
      <div><label>Label<br/><input id="doc_label" placeholder="Sales Register (CSV)"/></label></div>
      <div><label>Client Uploads?<br/><select id="doc_client"><option value="1">Yes</option><option value="0">No</option></select></label></div>
      <div><label>Versioned?<br/><select id="doc_versioned"><option value="1">Yes</option><option value="0">No</option></select></label></div>
      <div><label>Deliverable?<br/><select id="doc_deliv"><option value="0">No</option><option value="1">Yes</option></select></label></div>
      <div><label>Internal?<br/><select id="doc_internal"><option value="0">No</option><option value="1">Yes</option></select></label></div>
      <button onclick="addDocType()">Add Doc Type</button>
      <button onclick="listDocTypes()">List Doc Types</button>
    </div>
    <div id="doc_list" style="margin-top:12px;"></div>
  </div>

  <!-- WORKFLOW TEMPLATE JSON -->
  <h2>3) Workflow Template (JSON)</h2>
  <div class="card">
    <div class="row">
      <div><label>Service Key<br/><input id="wf_service_key" placeholder="gst_returns"/></label></div>
      <button onclick="loadWorkflow()">Load</button>
    </div>
    <textarea id="wf_json" placeholder='{"steps":[...], "dependencies":[...], "slas":{...}}'></textarea>
    <div class="row">
      <button onclick="saveWorkflow()">Save New Version</button>
      <div><label>Version to Publish<br/><input id="wf_version" type="number" min="1" /></label></div>
      <button onclick="publishWorkflow()">Publish Version</button>
    </div>
    <div id="wf_info" class="muted"></div>
  </div>

  <!-- DUE DATE MASTER -->
  <h2>4) Due Date Master</h2>
  <div class="card">
    <div class="row">
      <div><label>Service Key<br/><input id="dd_service_key" placeholder="gst_returns"/></label></div>
      <div><label>Jurisdiction<br/><input id="dd_juris" value="IN"/></label></div>
      <div><label>Effective From (YYYY-MM-DD)<br/><input id="dd_from" placeholder="2025-04-01"/></label></div>
      <div><label>Effective To (optional)<br/><input id="dd_to" placeholder=""/></label></div>
      <button onclick="listDueDates()">List</button>
    </div>
    <textarea id="dd_rule" placeholder='{"periodicity":"MONTHLY","dueDayOfMonth":20,"nudges":{"tMinus":[7,3,1],"fixedDays":[1,2]}}'></textarea>
    <div class="row">
      <button onclick="addDueRule()">Add Rule</button>
    </div>
    <div id="dd_list" class="muted"></div>
  </div>

  <!-- BIND SERVICE TO CLIENT -->
  <h2>5) Bind Service → Entity</h2>
  <div class="card">
    <div class="row">
      <div><label>Entity ID<br/><input id="bind_entity" type="number" value="1"/></label></div>
      <div><label>Service Key<br/><input id="bind_service" placeholder="gst_returns"/></label></div>
      <div><label>Periodicity Override (optional)<br/>
        <select id="bind_period_override"><option></option><option>MONTHLY</option><option>QUARTERLY</option><option>ANNUAL</option></select></label></div>
      <div><label>Jurisdiction<br/><input id="bind_juris" value="IN"/></label></div>
      <div><label>Meta JSON (optional)<br/><input id="bind_meta" placeholder='{"scheme":"QRMP"}'/></label></div>
      <button onclick="bindService()">Bind</button>
    </div>
    <p class="muted">Spawner will create the period Service Orders automatically at 06:30 IST daily (you added this earlier). Adjust cron if you want instant spawn for demo.</p>
  </div>

  <!-- QUICK PREVIEW OF SERVICE ORDERS -->
  <h2>6) Preview Service Orders</h2>
  <div class="card">
    <div class="row">
      <div><label>Filter Status<br/>
        <select id="so_status"><option></option><option>Created</option><option>In Progress</option><option>Waiting on Client</option><option>Completed</option></select></label></div>
      <div><label>Service Type<br/><input id="so_type" placeholder="gst_returns"/></label></div>
      <button onclick="loadOrders()">Load</button>
    </div>
    <div id="so_list"></div>
  </div>

<script>
const api = (p, opt={}) => fetch(p, { headers:{'Content-Type':'application/json'}, ...opt }).then(r=>r.json());

async function addService(){
  const body = {
    service_key: v('svc_key'), name: v('svc_name'),
    periodicity: v('svc_periodicity'), description: v('svc_desc')
  };
  const res = await api('/admin/services', { method:'POST', body: JSON.stringify(body) });
  ok(res, 'Service added');
  await loadServices();
}
async function loadServices(){
  const rows = await api('/admin/services');
  const html = ['<table><tr><th>Key</th><th>Name</th><th>Periodicity</th><th>Active</th></tr>']
    .concat(rows.map(r=>`<tr><td>${r.service_key}</td><td>${r.name}</td><td><span class="pill">${r.periodicity}</span></td><td>${r.is_active?'Yes':'No'}</td></tr>`))
    .concat('</table>').join('');
  document.getElementById('svc_list').innerHTML = html;
}
async function addDocType(){
  const key = v('doc_service_key');
  const body = {
    doctype: v('doc_doctype'),
    label: v('doc_label'),
    client_uploads: +v('doc_client'),
    versioned: +v('doc_versioned'),
    is_deliverable: +v('doc_deliv'),
    is_internal: +v('doc_internal')
  };
  const res = await api(`/admin/services/${key}/doc-types`, { method:'POST', body: JSON.stringify(body) });
  ok(res, 'Doc type added'); await listDocTypes();
}
async function listDocTypes(){
  const key = v('doc_service_key');
  const rows = await api(`/admin/services/${key}/doc-types`);
  const html = ['<table><tr><th>Doctype</th><th>Label</th><th>Client</th><th>Deliverable</th><th>Internal</th></tr>']
    .concat(rows.map(r=>`<tr><td>${r.doctype}</td><td>${r.label}</td><td>${r.client_uploads?'Yes':'No'}</td><td>${r.is_deliverable?'Yes':'No'}</td><td>${r.is_internal?'Yes':'No'}</td></tr>`))
    .concat('</table>').join('');
  document.getElementById('doc_list').innerHTML = html;
}
async function loadWorkflow(){
  const key = v('wf_service_key');
  const rows = await api(`/admin/workflows/${key}`);
  if(!rows.length){ document.getElementById('wf_info').textContent='No versions yet'; return; }
  document.getElementById('wf_json').value = JSON.stringify(JSON.parse(rows[0].template_json), null, 2);
  document.getElementById('wf_info').textContent = `Latest version: ${rows[0].version} | Published: ${rows[0].is_published?'Yes':'No'}`;
}
async function saveWorkflow(){
  try {
    const key = v('wf_service_key');
    const json = JSON.parse(document.getElementById('wf_json').value);
    const res = await api(`/admin/workflows/${key}`, { method:'POST', body: JSON.stringify({ template_json: json, is_published:0 }) });
    ok(res, `Saved v${res.version}`);
    await loadWorkflow();
  } catch(e){ err(e); }
}
async function publishWorkflow(){
  const key = v('wf_service_key');
  const ver = +v('wf_version');
  const res = await api(`/admin/workflows/${key}/publish`, { method:'POST', body: JSON.stringify({ version: ver }) });
  ok(res, 'Published'); await loadWorkflow();
}
async function addDueRule(){
  const key = v('dd_service_key');
  const body = {
    jurisdiction: v('dd_juris'),
    rule_json: JSON.parse(document.getElementById('dd_rule').value),
    effective_from: v('dd_from') || new Date().toISOString().slice(0,10),
    effective_to: v('dd_to') || null
  };
  const res = await api(`/admin/due-dates/${key}`, { method:'POST', body: JSON.stringify(body) });
  ok(res, 'Rule added'); await listDueDates();
}
async function listDueDates(){
  const key = v('dd_service_key');
  const rows = await api(`/admin/due-dates/${key}`);
  document.getElementById('dd_list').textContent = JSON.stringify(rows, null, 2);
}
async function bindService(){
  const body = {
    service_key: v('bind_service'),
    periodicity_override: v('bind_period_override') || null,
    jurisdiction: v('bind_juris') || 'IN',
    meta_json: v('bind_meta') ? JSON.parse(v('bind_meta')) : null
  };
  const res = await api(`/admin/entities/${v('bind_entity')}/services`, { method:'POST', body: JSON.stringify(body) });
  ok(res, 'Bound to entity');
}
async function loadOrders(){
  const qs = new URLSearchParams();
  const st = v('so_status'); const ty = v('so_type');
  if(st) qs.set('status', st); if(ty) qs.set('service_type', ty);
  const rows = await api(`/service-orders?${qs.toString()}`);
  const html = ['<table><tr><th>ID</th><th>Entity</th><th>Service</th><th>Period</th><th>Due</th><th>Status</th></tr>']
    .concat(rows.map(r=>`<tr><td>${r.id}</td><td>${r.entity_name}</td><td>${r.service_type}</td><td>${r.period_label}</td><td>${r.due_date}</td><td>${r.status}</td></tr>`))
    .concat('</table>').join('');
  document.getElementById('so_list').innerHTML = html;
}

// helpers
function v(id){ return document.getElementById(id).value.trim(); }
function ok(res, msg){ console.log(res); alert('✅ ' + msg); }
function err(e){ console.error(e); alert('❌ ' + (e.message || e)); }

// initial loads
loadServices();
</script>
</body>
</html>


---

3.2 Ops Board (public/ops.html)

A minimal page for your ops to see their queue and flip statuses fast (which in turn triggers your notifications).

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DigiComply Ops Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    h1 { margin-bottom: 8px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; }
    input, select, button { padding:8px 10px; border-radius:8px; border:1px solid #e5e7eb; font-size:14px; }
    button { background:#111827; color:#fff; border:none; cursor:pointer; }
    table { border-collapse: collapse; width:100%; margin-top:12px; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; font-size:14px; }
    .small { font-size:12px; color:#6b7280; }
  </style>
</head>
<body>
  <h1>Ops Board</h1>
  <div class="row">
    <div><label>Status Filter<br/>
      <select id="f_status"><option></option><option>Created</option><option>In Progress</option><option>Waiting on Client</option><option>Completed</option></select>
    </label></div>
    <div><label>Service Type<br/><input id="f_type" placeholder="gst_returns"/></label></div>
    <button onclick="load()">Load</button>
  </div>
  <div id="list"></div>

<script>
const api = (p, opt={}) => fetch(p, { headers:{'Content-Type':'application/json'}, ...opt }).then(r=>r.json());

async function load(){
  const qs = new URLSearchParams();
  const s = v('f_status'); const t = v('f_type');
  if(s) qs.set('status', s); if(t) qs.set('service_type', t);
  const rows = await api(`/service-orders?${qs.toString()}`);
  render(rows);
}
function render(rows){
  const html = ['<table><tr><th>ID</th><th>Entity</th><th>Service</th><th>Period</th><th>Due</th><th>Status</th><th>Actions</th></tr>'];
  html.push(...rows.map(r => {
    return `<tr>
      <td>${r.id}</td>
      <td>${r.entity_name}</td>
      <td>${r.service_type}</td>
      <td>${r.period_label}</td>
      <td>${r.due_date}</td>
      <td>${r.status}</td>
      <td>
        <button onclick="setStatus(${r.id}, '${r.status}', 'In Progress')">Start</button>
        <button onclick="setStatus(${r.id}, '${r.status}', 'Waiting on Client')">Wait Client</button>
        <button onclick="setStatus(${r.id}, '${r.status}', 'Completed')">Complete</button>
      </td>
    </tr>`;
  }));
  html.push('</table><p class="small">Changing status triggers client notifications based on your rules.</p>');
  document.getElementById('list').innerHTML = html.join('');
}
async function setStatus(id, from, to){
  const body = { from, to };
  if (to === 'Completed') body.ackNo = prompt('Ack No (optional):', '') || '';
  const res = await api(`/service-orders/${id}/status`, { method:'PATCH', body: JSON.stringify(body) });
  if(res.ok){ alert('✅ Updated'); load(); } else { alert('❌ Failed'); }
}
function v(id){ return document.getElementById(id).value.trim(); }
load();
</script>
</body>
</html>


---

4) How this lands for your customers & employees

Admin can now create services, attach doc types, publish workflows, set due-date rules, and bind services to clients — no code.

Ops has a one-screen board to drive statuses; this kicks your auto-reminders & filing confirmations.

Clients benefit immediately: on-time nudges, clear status change notifications, and smoother periods.



---

5) Suggested next micro-upgrades (fast wins)

Add a “Preview due date” button in Admin UI that computes the next due from a selected Due Date Master rule (use your computeDueDate function server-side).

Add a “Generate demo period now” button to call your Spawner on demand for a specific entity/service (handy in sales demos).

Add per-rule quiet hours and per-client channel preferences in Admin UI (you already support it in the engine).

Add CSV export of service orders from Admin UI for audits.



---

If you want, I can also share a tiny Client page that lists a client’s services and shows current period status + next actions + doc uploads (using a simple mock upload endpoint).

