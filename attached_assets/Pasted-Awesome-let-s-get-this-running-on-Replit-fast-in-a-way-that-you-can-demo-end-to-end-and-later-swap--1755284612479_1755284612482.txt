Awesome—let’s get this running on Replit fast, in a way that you can demo end-to-end and later swap pieces (DB, queues, providers) without rewriting.

Below is a turn-key Replit setup for:

Admin-configurable rules (schedule + event)

Status change → event → notifications (Email + WhatsApp stubs)

GST/TDS/State reminder schedules

Minimal DB (SQLite) on Replit (easy), with a clear path to Postgres later


You’ll copy–paste these files into a new Node.js Replit and be live.


---

0) Tech choices (Replit-friendly now, upgradable later)

Runtime: Node.js + Express

DB (demo): SQLite (file-based, persists on Replit). Later: switch to Postgres (Supabase/Neon) by replacing db.ts.

Scheduler: node-cron

Event bus: in-process emitter (eventemitter3) — replace with BullMQ + Upstash Redis later.

Email sender: log to console in demo; swap to Resend/SendGrid later.

WhatsApp sender: log to console; swap to WABA provider later.



---

1) Replit project structure

/ (root)
├─ index.js
├─ db.js
├─ rules.js
├─ scheduler.js
├─ eventBus.js
├─ senders/
│  ├─ email.js
│  └─ whatsapp.js
├─ templates.js
├─ routes/
│  ├─ serviceOrders.js
│  └─ documents.js
├─ seed.sql
├─ package.json
└─ .replit (Replit auto)


---

2) package.json

{
  "name": "digicomply-replit",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node index.js",
    "seed": "node -e \"import('./db.js').then(m=>m.runSeed())\""
  },
  "dependencies": {
    "better-sqlite3": "^9.4.3",
    "dotenv": "^16.4.5",
    "eventemitter3": "^5.0.1",
    "express": "^4.19.2",
    "node-cron": "^3.0.3",
    "uuid": "^9.0.1"
  }
}


---

3) seed.sql (DB schema + minimal data)

-- core tables (trimmed to what we need for notifications demo)
create table if not exists service_orders (
  id integer primary key autoincrement,
  entity_id integer not null,
  service_type text not null,
  periodicity text,
  period_label text,
  due_date text,      -- ISO string
  status text default 'Created', -- Created/In Progress/Waiting on Client/Completed
  created_at text default (datetime('now')),
  updated_at text default (datetime('now'))
);

create table if not exists entities (
  id integer primary key autoincrement,
  name text not null
);

create table if not exists entity_contacts (
  id integer primary key autoincrement,
  entity_id integer not null,
  name text,
  email text,
  phone text,
  wa_opt_in integer default 1
);

create table if not exists notification_rules (
  id integer primary key autoincrement,
  rule_key text unique not null,
  type text not null,  -- SCHEDULE/EVENT
  scope_json text not null,
  schedule_json text,
  logic_json text,
  filters_json text,
  channels_json text not null,
  template_key text not null,
  dedupe_window_mins integer default 120,
  respect_quiet_hours integer default 1,
  is_enabled integer default 1,
  created_at text default (datetime('now')),
  updated_at text default (datetime('now'))
);

create table if not exists notification_outbox (
  id integer primary key autoincrement,
  rule_key text not null,
  service_order_id integer not null,
  entity_id integer not null,
  recipient_email text,
  recipient_phone text,
  channel text not null,   -- EMAIL/WHATSAPP/INAPP
  template_key text not null,
  payload_json text not null,
  dedupe_fingerprint text,
  scheduled_at text not null,
  status text default 'QUEUED', -- QUEUED/SENT/DELIVERED/FAILED/CANCELLED
  error text,
  created_at text default (datetime('now'))
);

create table if not exists notification_templates (
  template_key text primary key,
  channel text not null,
  subject text,
  body text not null
);

create table if not exists domain_events (
  id integer primary key autoincrement,
  event_key text not null,
  payload_json text not null,
  occurred_at text default (datetime('now'))
);

-- minimal demo data
insert into entities (name) values ('Acme Pvt Ltd');
insert into entity_contacts (entity_id, name, email, phone) values (1, 'Founder', 'founder@example.com', '+911234567890');

-- one GST service order due this month (edit date as you like)
insert into service_orders (entity_id, service_type, periodicity, period_label, due_date, status)
values (1, 'gst_returns', 'MONTHLY', 'Aug-2025', '2025-08-20', 'Created');


---

4) db.js (SQLite helper + seed runner)

import Database from 'better-sqlite3';
import fs from 'fs';

const db = new Database('digicomply.db', { verbose: null });

export function runSeed() {
  const sql = fs.readFileSync('./seed.sql', 'utf-8');
  db.exec(sql);
  console.log('Seed done.');
}

export default db;

> In Replit shell:
npm install
npm run seed




---

5) eventBus.js (simple event emitter)

import EventEmitter from 'eventemitter3';
export const bus = new EventEmitter();

// helper to emit domain events & persist (optional)
import db from './db.js';

export function emitEvent(event_key, payload) {
  db.prepare(`insert into domain_events (event_key, payload_json) values (?, ?)`)
    .run(event_key, JSON.stringify(payload));
  bus.emit(event_key, payload);
}


---

6) templates.js (email/WA templates)

import db from './db.js';

export function seedTemplates() {
  const up = db.prepare(`insert or ignore into notification_templates
    (template_key, channel, subject, body) values (?, ?, ?, ?)`);

  up.run('GST_REMINDER_GENERIC', 'EMAIL',
    'GST Return – Action Needed for {{entityName}} ({{periodLabel}})',
    `Hello {{clientFirstName}},
GST return for {{entityName}} ({{periodLabel}}) is due on {{dueDate}}.
Next step: {{nextClientAction}}
Portal: {{portalDeepLink}}
— DigiComply`);

  up.run('GST_DUE_NUDGE', 'WHATSAPP', null,
    `GST return for *{{entityName}}* ({{periodLabel}}) is due on {{dueDate}}. Complete: {{portalDeepLink}}`);

  up.run('FILING_DONE_CONFIRMATION', 'EMAIL',
    'Filing Completed – {{serviceName}} ({{periodLabel}})',
    `Filing completed for {{entityName}} – {{serviceName}} ({{periodLabel}}).
Ack: {{ackNo}}. Download: {{portalDeepLink}}`);

  up.run('CLIENT_PENDENCY_ALERT', 'EMAIL',
    'Action Needed – {{serviceName}} ({{periodLabel}})',
    `Your action is pending for {{serviceName}} ({{periodLabel}}): {{pendingItem}}.
Do it here: {{portalDeepLink}}`);

  up.run('DOC_REJECTED_REUPLOAD', 'EMAIL',
    'Document Rejected – {{serviceName}} ({{periodLabel}})',
    `The document {{docType}} was rejected for {{serviceName}} ({{periodLabel}}).
Reason: {{reason}}. Re-upload: {{portalDeepLink}}`);
}

Call seedTemplates() once from index.js on first run.


---

7) senders/email.js & senders/whatsapp.js (stubs now, pluggable later)

// senders/email.js
export async function sendEmail(to, subject, body) {
  console.log('[EMAIL] →', to, '|', subject, '|', body.slice(0, 120), '...');
  return { providerId: 'demo-email-123' };
}

// senders/whatsapp.js
export async function sendWhatsApp(to, body) {
  console.log('[WHATSAPP] →', to, '|', body);
  return { providerId: 'demo-wa-123' };
}


---

8) rules.js (seed the rules you specified)

import db from './db.js';

export function seedRules() {
  const insert = db.prepare(`insert or ignore into notification_rules
    (rule_key, type, scope_json, schedule_json, logic_json, filters_json, channels_json, template_key,
     dedupe_window_mins, respect_quiet_hours, is_enabled)
    values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`);

  // GST 1st & 2nd monthly (09:00 IST)
  insert.run(
    'gst_monthly_reminders_1st_2nd',
    'SCHEDULE',
    JSON.stringify({ serviceType: 'gst_returns', periodicity: 'MONTHLY' }),
    JSON.stringify({ cron: '0 9 1,2 * *', timezone: 'Asia/Kolkata' }),
    null,
    JSON.stringify([
      { field: 'serviceOrder.status', op: 'IN', value: ['Created','In Progress','Waiting on Client'] }
    ]),
    JSON.stringify(['EMAIL','WHATSAPP']),
    'GST_REMINDER_GENERIC',
    120, 1, 1
  );

  // GST due T-7/T-3/T-1 (run every 30 mins)
  insert.run(
    'gst_due_smart_nudges',
    'SCHEDULE',
    JSON.stringify({ serviceType: 'gst_returns' }),
    JSON.stringify({ cron: '*/30 * * * *', timezone: 'Asia/Kolkata' }),
    JSON.stringify({ relativeDueDays: [-7,-3,-1] }),
    JSON.stringify([{ field: 'serviceOrder.status', op: 'NE', value: 'Completed' }]),
    JSON.stringify(['EMAIL','WHATSAPP']),
    'GST_DUE_NUDGE',
    1440, 1, 1
  );

  // TDS quarterly (1st of Apr/Jul/Oct/Jan at 10:00)
  insert.run(
    'tds_quarterly_reminders',
    'SCHEDULE',
    JSON.stringify({ serviceType: 'tds_quarterly' }),
    JSON.stringify({ cron: '0 10 1 4,7,10,1 *', timezone: 'Asia/Kolkata' }),
    null,
    JSON.stringify([{ field: 'serviceOrder.status', op: 'NE', value: 'Completed' }]),
    JSON.stringify(['EMAIL','WHATSAPP']),
    'TDS_QUARTERLY_REMINDER', 120, 1, 1
  );

  // State/HSY monthly (1st 09:00)
  insert.run(
    'state_hsy_monthly',
    'SCHEDULE',
    JSON.stringify({ serviceType: 'state_hsy_monthly' }),
    JSON.stringify({ cron: '0 9 1 * *', timezone: 'Asia/Kolkata' }),
    null,
    JSON.stringify([{ field: 'serviceOrder.status', op: 'NE', value: 'Completed' }]),
    JSON.stringify(['EMAIL','WHATSAPP']),
    'STATE_GENERIC_MONTHLY_REMINDER', 120, 1, 1
  );

  // Service status changed → notify
  insert.run(
    'service_status_change_notify',
    'EVENT',
    JSON.stringify({}),
    null,
    JSON.stringify({
      transitions: [
        { from: ['Created','In Progress','Waiting on Client','QA Review'], to: 'Completed',
          action: { channels: ['EMAIL','WHATSAPP'], template: 'FILING_DONE_CONFIRMATION' } },
        { from: ['Created','In Progress'], to: 'Waiting on Client',
          action: { channels: ['EMAIL','WHATSAPP'], template: 'CLIENT_PENDENCY_ALERT' } }
      ],
      dedupeWindowMins: 15
    }),
    null,
    JSON.stringify(['EMAIL','WHATSAPP']),
    'FILING_DONE_CONFIRMATION', 15, 1, 1
  );

  // Document rejected → notify
  insert.run(
    'doc_rejected_notify',
    'EVENT',
    JSON.stringify({}),
    null,
    null,
    null,
    JSON.stringify(['EMAIL','WHATSAPP']),
    'DOC_REJECTED_REUPLOAD', 15, 1, 1
  );

  console.log('Rules seeded.');
}


---

9) scheduler.js (cron + event handlers → outbox)

import cron from 'node-cron';
import db from './db.js';
import { bus } from './eventBus.js';

// helper to render template
function render(body, vars) {
  return body.replace(/\{\{(\w+)\}\}/g, (_, k) => vars[k] ?? '');
}

// enqueue function
function enqueue(rule, so, contact, templateKey, payload, channel) {
  const fp = `${rule.rule_key}|${so.id}|${templateKey}|${channel}`;
  const scheduledAt = new Date().toISOString();

  try {
    db.prepare(`insert into notification_outbox
      (rule_key, service_order_id, entity_id, recipient_email, recipient_phone, channel, template_key, payload_json, dedupe_fingerprint, scheduled_at)
      values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`)
      .run(rule.rule_key, so.id, so.entity_id, contact?.email || null, contact?.phone || null,
           channel, templateKey, JSON.stringify(payload), fp, scheduledAt);
  } catch (e) {
    if (String(e).includes('dedupe')) {
      // already queued recently
    } else {
      console.error('enqueue error', e);
    }
  }
}

// Scheduled GST 1st/2nd etc.
function registerSchedule(rule) {
  const { cron: cronExpr } = JSON.parse(rule.schedule_json);
  cron.schedule(cronExpr, () => {
    const scope = JSON.parse(rule.scope_json);
    const filters = rule.filters_json ? JSON.parse(rule.filters_json) : [];
    const sos = db.prepare(`
      select s.*, e.name as entity_name, c.email, c.phone
      from service_orders s
      join entities e on e.id = s.entity_id
      left join entity_contacts c on c.entity_id = s.entity_id
      where s.service_type = ?
    `).all(scope.serviceType);

    sos.forEach(so => {
      // simple filter eval (extend as needed)
      const statusOk = !filters.length || filters.every(f => {
        if (f.field === 'serviceOrder.status' && f.op === 'NE') return so.status !== f.value;
        if (f.field === 'serviceOrder.status' && f.op === 'IN') return f.value.includes(so.status);
        return true;
      });

      if (!statusOk) return;

      const payload = {
        entityName: so.entity_name,
        periodLabel: so.period_label,
        dueDate: so.due_date,
        nextClientAction: 'Upload/review docs',
        portalDeepLink: `https://app.digicomply.example/entity/${so.entity_id}/service/${so.id}`
      };

      const channels = JSON.parse(rule.channels_json);
      channels.forEach(ch => enqueue(rule, so, {email: so.email, phone: so.phone}, rule.template_key, payload, ch));
    });
  }, { timezone: JSON.parse(rule.schedule_json).timezone || 'Asia/Kolkata' });

  console.log('Scheduled rule', rule.rule_key);
}

// GST due T-7/T-3/T-1
function registerSmartDue(rule) {
  const logic = JSON.parse(rule.logic_json || '{}');
  const rels = logic.relativeDueDays || [-7,-3,-1];
  cron.schedule(JSON.parse(rule.schedule_json).cron, () => {
    const sos = db.prepare(`
      select s.*, e.name as entity_name, c.email, c.phone
      from service_orders s
      join entities e on e.id = s.entity_id
      left join entity_contacts c on c.entity_id = s.entity_id
      where s.service_type = 'gst_returns' and s.status <> 'Completed'
    `).all();

    const today = new Date();

    sos.forEach(so => {
      const due = new Date(so.due_date);
      const diffDays = Math.ceil((due - today) / (1000*60*60*24));
      if (!rels.includes(diffDays)) return;

      const payload = {
        entityName: so.entity_name,
        periodLabel: so.period_label,
        dueDate: so.due_date,
        portalDeepLink: `https://app.digicomply.example/entity/${so.entity_id}/service/${so.id}`
      };

      JSON.parse(rule.channels_json).forEach(ch =>
        enqueue(rule, so, {email: so.email, phone: so.phone}, rule.template_key, payload, ch)
      );
    });
  }, { timezone: 'Asia/Kolkata' });

  console.log('Scheduled smart due', rule.rule_key);
}

// Event handlers
function registerEvents(rule) {
  const logic = JSON.parse(rule.logic_json || '{}');

  bus.on('service.status_changed', (evt) => {
    const { service_order_id, from, to, ackNo, entityName, periodLabel, serviceName, portalDeepLink, pendingItem } = evt;

    const so = db.prepare(`select s.*, e.name as entity_name, c.email, c.phone
      from service_orders s
      join entities e on e.id = s.entity_id
      left join entity_contacts c on c.entity_id = s.entity_id
      where s.id = ?`).get(service_order_id);

    if (!so) return;

    // transitions in logic
    const t = (logic.transitions || []).find(tr =>
      (tr.from.includes(from) || tr.from === 'ANY') && tr.to === to
    );
    if (!t) return;

    const action = t.action;
    const payload = {
      entityName: entityName || so.entity_name,
      serviceName: serviceName || so.service_type,
      periodLabel: periodLabel || so.period_label,
      ackNo: ackNo || '',
      pendingItem: pendingItem || '',
      portalDeepLink: portalDeepLink || `https://app.digicomply.example/entity/${so.entity_id}/service/${so.id}`
    };

    action.channels.forEach(ch =>
      enqueue({ rule_key: rule.rule_key, template_key: action.template }, so, {email: so.email, phone: so.phone}, action.template, payload, ch)
    );
  });

  bus.on('document.rejected', (evt) => {
    const { service_order_id, docType, reason } = evt;

    const so = db.prepare(`select s.*, e.name as entity_name, c.email, c.phone
      from service_orders s
      join entities e on e.id = s.entity_id
      left join entity_contacts c on c.entity_id = s.entity_id
      where s.id = ?`).get(service_order_id);

    if (!so) return;

    const payload = {
      entityName: so.entity_name,
      serviceName: so.service_type,
      periodLabel: so.period_label,
      docType, reason,
      portalDeepLink: `https://app.digicomply.example/entity/${so.entity_id}/service/${so.id}`
    };

    JSON.parse(rule.channels_json).forEach(ch =>
      enqueue(rule, so, {email: so.email, phone: so.phone}, rule.template_key, payload, ch)
    );
  });

  console.log('Event rule registered', rule.rule_key);
}

export function initSchedulersAndEvents() {
  const rules = db.prepare(`select * from notification_rules where is_enabled = 1`).all();
  rules.forEach(r => {
    if (r.type === 'SCHEDULE' && r.logic_json && JSON.parse(r.logic_json).relativeDueDays) registerSmartDue(r);
    else if (r.type === 'SCHEDULE') registerSchedule(r);
    else if (r.type === 'EVENT') registerEvents(r);
  });
}


---

10) routes (status/doc change endpoints)

routes/serviceOrders.js

import express from 'express';
import db from '../db.js';
import { emitEvent } from '../eventBus.js';

const router = express.Router();

router.patch('/:id/status', (req, res) => {
  const id = Number(req.params.id);
  const { from, to, ackNo, pendingItem } = req.body || {};
  const so = db.prepare(`select * from service_orders where id = ?`).get(id);
  if (!so) return res.status(404).json({ error: 'Not found' });

  db.prepare(`update service_orders set status = ?, updated_at = datetime('now') where id = ?`).run(to, id);

  emitEvent('service.status_changed', {
    service_order_id: id, from, to, ackNo, pendingItem,
    serviceName: so.service_type, periodLabel: so.period_label
  });

  res.json({ ok: true });
});

export default router;

routes/documents.js

import express from 'express';
import { emitEvent } from '../eventBus.js';

const router = express.Router();

router.post('/:id/reject', (req, res) => {
  const { reason, serviceOrderId, docType } = req.body || {};
  if (!serviceOrderId || !docType) return res.status(400).json({ error: 'serviceOrderId & docType required' });

  emitEvent('document.rejected', { service_order_id: serviceOrderId, reason, docType });
  res.json({ ok: true });
});

export default router;


---

11) index.js (wire everything + outbox sender loop)

import express from 'express';
import dotenv from 'dotenv';
dotenv.config();

import db, { runSeed } from './db.js';
import { seedTemplates } from './templates.js';
import { seedRules } from './rules.js';
import { initSchedulersAndEvents } from './scheduler.js';

import serviceOrders from './routes/serviceOrders.js';
import documents from './routes/documents.js';

import { sendEmail } from './senders/email.js';
import { sendWhatsApp } from './senders/whatsapp.js';

const app = express();
app.use(express.json());

// one-time seed on empty DB
seedTemplates();
seedRules();

// start schedulers & event handlers
initSchedulersAndEvents();

// simple sender loop (poll every 15s)
setInterval(async () => {
  const rows = db.prepare(`
    select o.*, t.subject, t.body
    from notification_outbox o
    join notification_templates t on t.template_key = o.template_key and t.channel = o.channel
    where o.status = 'QUEUED'
    order by o.id asc
    limit 10
  `).all();

  for (const r of rows) {
    // quiet hours (22:00–07:00 IST) → skip send, leave QUEUED
    const hourIST = new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata', hour: '2-digit', hour12: false });
    const h = parseInt(hourIST, 10);
    const inQuiet = (h >= 22 || h < 7);

    // respect quiet hours unless template is critical (extend with metadata if needed)
    const rule = db.prepare(`select respect_quiet_hours from notification_rules where rule_key = ?`).get(r.rule_key);
    if (rule?.respect_quiet_hours && inQuiet) continue;

    const vars = JSON.parse(r.payload_json);
    const subject = (r.subject || '').replace(/\{\{(\w+)\}\}/g, (_, k) => vars[k] ?? '');
    const body = (r.body || '').replace(/\{\{(\w+)\}\}/g, (_, k) => vars[k] ?? '');

    try {
      if (r.channel === 'EMAIL') {
        await sendEmail(r.recipient_email, subject, body);
      } else if (r.channel === 'WHATSAPP') {
        await sendWhatsApp(r.recipient_phone, body);
      } else {
        console.log('[INAPP]', body);
      }

      db.prepare(`update notification_outbox set status = 'SENT' where id = ?`).run(r.id);
    } catch (e) {
      db.prepare(`update notification_outbox set status = 'FAILED', error = ? where id = ?`).run(String(e), r.id);
    }
  }
},

